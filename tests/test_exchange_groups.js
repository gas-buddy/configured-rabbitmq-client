import tap from 'tap';
import _ from 'lodash';
import { normalizeExchangeGroups, rabbotConfigFromExchangeGroups } from '../src/exchangeGroups';

const simpleCase = {
  keys: 'simplekey',
};

const noRetryCase = {
  retries: 0,
  keys: 'noretrykey',
};

const complexCase = {
  retryDelay: 10,
  exchange: 'conf.ex',
  queue: {
    name: 'autodeletequeue',
    autoDelete: true,
  },
  retryQueue: 'crazyretryqueuename',
  keys: ['somekey', 'someotherkey'],
};

const rejectedOnlyCase = {
  retries: 0,
  rejectedExchange: true,
  keys: 'rejectedonlykey',
};

const perMessageTtl = {
  perMessageTtl: true,
  keys: 'somekey',
};

const exchangeGroups = {
  simpleCase,
  noRetryCase,
  complexCase,
  rejectedOnlyCase,
  perMessageTtl,
};


tap.test('test exchange group normalization', async (t) => {
  const finalGroups = normalizeExchangeGroups(exchangeGroups);

  t.ok(finalGroups.simpleCase.exchange.name === 'simpleCase', 'Exchange should be named the same as the group');
  t.ok(finalGroups.simpleCase.queue.name === 'simpleCase.q', 'Exchange should be named the same as the group with q');
  t.ok(finalGroups.simpleCase.retries > 0
       && finalGroups.simpleCase.retryDelay > 0
       && finalGroups.simpleCase.retryExchange
       && finalGroups.simpleCase.retryQueue
       && finalGroups.simpleCase.rejectedExchange
       && finalGroups.simpleCase.rejectedQueue, 'Retry queues should be generated by default');

  t.ok(!finalGroups.noRetryCase.retryExchange
       && !finalGroups.noRetryCase.retryQueue
       && !finalGroups.noRetryCase.rejectedExchange
       && !finalGroups.noRetryCase.rejectedQueue, 'Retry queues should not be generated when retries is set to 0');

  t.ok(finalGroups.complexCase.queue.name === complexCase.queue.name, 'Deep queue name is accepted');
  t.ok(finalGroups.complexCase.queue.autoDelete === complexCase.queue.autoDelete, 'Deep queue properties are accepted');
  t.ok(finalGroups.complexCase.retryQueue.name === complexCase.retryQueue, 'Additional queue overrides are accepted.');
  t.ok(finalGroups.complexCase.retryQueue.messageTtl === complexCase.retryDelay, 'messageTtl should match retryDelay on retry queue');

  t.ok(finalGroups.rejectedOnlyCase.exchange
       && finalGroups.rejectedOnlyCase.queue
       && !finalGroups.rejectedOnlyCase.retryExchange
       && !finalGroups.rejectedOnlyCase.retryQueue
       && finalGroups.rejectedOnlyCase.rejectedExchange
       && finalGroups.rejectedOnlyCase.rejectedQueue && 'Rejected queue should be generated when specified with zero retries');

  t.ok(finalGroups.perMessageTtl.retryQueue.messageTtl === undefined, 'retryQueue messageTtl should be undefined when perMessageTtl is requested');
  t.ok(finalGroups.perMessageTtl.retryQueue.name.indexOf('nottl') > 0, 'Retry queue should have "pmttl" in name when perMessageTtl is requested');
});

tap.test('test exchange group to rabbot config translation', async (t) => {
  const finalGroups = normalizeExchangeGroups(exchangeGroups);
  const rabbotConfig = rabbotConfigFromExchangeGroups(finalGroups);

  t.ok(_.find(rabbotConfig.queues, ['name', finalGroups.complexCase.queue.name]).autoDelete === complexCase.queue.autoDelete, 'Specific configuration propogates to rabbot config');
  t.ok(_.find(rabbotConfig.exchanges, ['name', finalGroups.rejectedOnlyCase.exchange.name]), 'No retry rejected exchange gets made');
});
